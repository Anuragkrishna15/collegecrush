-- =================================================================
-- === DEFINITIVE FIX FOR "prompts column does not exist" ERROR ===
-- This block explicitly adds the 'prompts' column if it is missing
-- and then tells the Supabase API to refresh its cache.
-- RUN THIS ENTIRE SCRIPT.
-- =================================================================
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT FROM pg_attribute
        WHERE attrelid = 'public.profiles'::regclass
        AND attname = 'prompts'
        AND NOT attisdropped
    ) THEN
        ALTER TABLE public.profiles ADD COLUMN prompts jsonb;
    END IF;
END $$;
NOTIFY pgrst, 'reload schema';
-- =================================================================


-- 1. ENUM TYPES (Create if they don't exist, safe to re-run)
DO $$ BEGIN CREATE TYPE public.membership_type AS ENUM ('Free', 'Trial', 'Premium'); EXCEPTION WHEN duplicate_object THEN null; END $$;
DO $$ BEGIN CREATE TYPE public.gender_enum AS ENUM ('Male', 'Female', 'Other'); EXCEPTION WHEN duplicate_object THEN null; END $$;
DO $$ BEGIN CREATE TYPE public.swipe_direction AS ENUM ('left', 'right'); EXCEPTION WHEN duplicate_object THEN null; END $$;
DO $$ BEGIN CREATE TYPE public.blind_date_status AS ENUM ('pending', 'accepted', 'completed', 'feedback_submitted'); EXCEPTION WHEN duplicate_object THEN null; END $$;
DO $$ BEGIN CREATE TYPE public.rsvp_status AS ENUM ('going', 'interested', 'none'); EXCEPTION WHEN duplicate_object THEN null; END $$;
DO $$ BEGIN CREATE TYPE public.trip_type AS ENUM ('Couple', 'Stranger'); EXCEPTION WHEN duplicate_object THEN null; END $$;
DO $$ BEGIN CREATE TYPE public.vibe_rating AS ENUM ('good', 'bad'); EXCEPTION WHEN duplicate_object THEN null; END $$;
DO $$ BEGIN CREATE TYPE public.report_type AS ENUM ('report', 'block'); EXCEPTION WHEN duplicate_object THEN null; END $$;
DO $$ BEGIN CREATE TYPE public.meal_type AS ENUM ('Breakfast', 'Lunch', 'Dinner', 'Coffee & Snacks'); EXCEPTION WHEN duplicate_object THEN null; END $$;
DO $$ BEGIN CREATE TYPE public.notification_type AS ENUM ('new_match', 'new_message', 'new_blind_date_request', 'blind_date_accepted', 'vibe_check_match'); EXCEPTION WHEN duplicate_object THEN null; END $$;

-- Enable PostGIS extension for location-based queries
CREATE EXTENSION IF NOT EXISTS postgis WITH SCHEMA extensions;


-- 2. TABLES (Create if they don't exist)
CREATE TABLE IF NOT EXISTS public.profiles (
    id uuid NOT NULL PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    name text NOT NULL,
    dob date NOT NULL,
    gender public.gender_enum NOT NULL,
    bio text NOT NULL,
    college text NOT NULL,
    course text NOT NULL,
    "profilePics" text[] NOT NULL,
    tags text[] NOT NULL,
    prompts jsonb,
    membership public.membership_type DEFAULT 'Free'::public.membership_type NOT NULL,
    email text NOT NULL UNIQUE,
    latitude numeric,
    longitude numeric
);
-- Add location columns if they don't exist for existing setups
DO $$
BEGIN
    IF NOT EXISTS (SELECT FROM pg_attribute WHERE attrelid = 'public.profiles'::regclass AND attname = 'latitude' AND NOT attisdropped) THEN
        ALTER TABLE public.profiles ADD COLUMN latitude numeric;
    END IF;
    IF NOT EXISTS (SELECT FROM pg_attribute WHERE attrelid = 'public.profiles'::regclass AND attname = 'longitude' AND NOT attisdropped) THEN
        ALTER TABLE public.profiles ADD COLUMN longitude numeric;
    END IF;
END $$;

CREATE TABLE IF NOT EXISTS public.swipes (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    swiper_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    swiped_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    direction public.swipe_direction NOT NULL,
    UNIQUE (swiper_id, swiped_id)
);
CREATE TABLE IF NOT EXISTS public.conversations (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    user1_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    user2_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    UNIQUE(user1_id, user2_id)
);
CREATE TABLE IF NOT EXISTS public.messages (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    conversation_id uuid NOT NULL REFERENCES public.conversations(id) ON DELETE CASCADE,
    sender_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    text text NOT NULL
);
CREATE TABLE IF NOT EXISTS public.events (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    name text NOT NULL,
    date text NOT NULL,
    college text NOT NULL,
    "imageUrl" text NOT NULL
);
CREATE TABLE IF NOT EXISTS public.event_rsvps (
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    event_id uuid NOT NULL REFERENCES public.events(id) ON DELETE CASCADE,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    status public.rsvp_status NOT NULL,
    PRIMARY KEY(user_id, event_id)
);
CREATE TABLE IF NOT EXISTS public.trips (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    location text NOT NULL,
    date text NOT NULL,
    type public.trip_type NOT NULL,
    slots integer NOT NULL,
    "imageUrl" text NOT NULL,
    fare integer NOT NULL DEFAULT 0,
    details text NOT NULL DEFAULT '',
    latitude numeric,
    longitude numeric
);
CREATE TABLE IF NOT EXISTS public.trip_bookings (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    trip_id uuid NOT NULL REFERENCES public.trips(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    UNIQUE(trip_id, user_id)
);
CREATE TABLE IF NOT EXISTS public.blind_dates (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    requesting_user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    requested_user_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE,
    cafe text NOT NULL,
    meal public.meal_type NOT NULL,
    time text NOT NULL,
    status public.blind_date_status DEFAULT 'pending'::public.blind_date_status NOT NULL,
    date_time timestamptz
);
-- Modify blind_dates for proposal system
ALTER TABLE public.blind_dates ALTER COLUMN requested_user_id DROP NOT NULL;
DO $$
BEGIN
    IF NOT EXISTS (SELECT FROM pg_attribute WHERE attrelid = 'public.blind_dates'::regclass AND attname = 'date_time' AND NOT attisdropped) THEN
        ALTER TABLE public.blind_dates ADD COLUMN date_time timestamptz;
    END IF;
END $$;

CREATE TABLE IF NOT EXISTS public.comments (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    profile_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    author_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    text text NOT NULL
);
CREATE TABLE IF NOT EXISTS public.reports_blocks (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    reporting_user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    reported_user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    reason text,
    type public.report_type NOT NULL,
    UNIQUE(reporting_user_id, reported_user_id)
);
CREATE TABLE IF NOT EXISTS public.vibe_checks (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    blind_date_id uuid NOT NULL REFERENCES public.blind_dates(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    rating public.vibe_rating,
    tags text[],
    UNIQUE(blind_date_id, user_id)
);
CREATE TABLE IF NOT EXISTS public.profile_boosts (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id uuid NOT NULL UNIQUE REFERENCES public.profiles(id) ON DELETE CASCADE,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    boost_end_time timestamp with time zone NOT NULL
);
CREATE TABLE IF NOT EXISTS public.rizz_scores (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    conversation_id uuid NOT NULL REFERENCES public.conversations(id) ON DELETE CASCADE,
    score integer NOT NULL,
    feedback text,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    UNIQUE(user_id, conversation_id)
);
CREATE TABLE IF NOT EXISTS public.notifications (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    type public.notification_type NOT NULL,
    message text NOT NULL,
    source_entity_id uuid,
    is_read boolean DEFAULT false NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);
CREATE TABLE IF NOT EXISTS public.payments (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    amount integer NOT NULL,
    currency text NOT NULL DEFAULT 'INR',
    plan public.membership_type NOT NULL,
    status text NOT NULL,
    provider text NOT NULL,
    provider_order_id text NULL,
    provider_payment_id text NULL
);
CREATE TABLE IF NOT EXISTS public.ads (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    title text NOT NULL,
    image_url text NOT NULL,
    link text NOT NULL
);

-- 3. DATABASE FUNCTIONS (These are idempotent, safe to re-run)
-- Function to update a user's location
CREATE OR REPLACE FUNCTION public.update_user_location(p_lat numeric, p_lon numeric)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  UPDATE public.profiles
  SET latitude = p_lat, longitude = p_lon
  WHERE id = auth.uid();
END;
$$;
-- Drop old blind date function
DROP FUNCTION IF EXISTS public.create_blind_date_request(uuid,text,text,public.meal_type);
DROP FUNCTION IF EXISTS public.propose_blind_date(text,timestamptz,public.meal_type);


-- New function for proposing a blind date that notifies nearby users
CREATE OR REPLACE FUNCTION public.propose_blind_date(
    p_cafe text,
    p_date_time timestamptz,
    p_meal public.meal_type
)
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_new_date_id uuid;
    v_proposer_id uuid := auth.uid();
    v_proposer_lat numeric;
    v_proposer_lon numeric;
    v_proposer_gender public.gender_enum;
    v_proposer_name text;
    v_target_gender public.gender_enum;
    nearby_user RECORD;
BEGIN
    -- Get proposer's details
    SELECT latitude, longitude, gender, name
    INTO v_proposer_lat, v_proposer_lon, v_proposer_gender, v_proposer_name
    FROM public.profiles
    WHERE id = v_proposer_id;

    -- Check if proposer has location data
    IF v_proposer_lat IS NULL OR v_proposer_lon IS NULL THEN
        RAISE EXCEPTION 'User location not set. Cannot propose a date.';
    END IF;

    -- Insert the new blind date proposal
    INSERT INTO public.blind_dates (requesting_user_id, cafe, date_time, meal, status, time)
    VALUES (v_proposer_id, p_cafe, p_date_time, p_meal, 'pending', to_char(p_date_time, 'YYYY-MM-DD HH24:MI:SS'))
    RETURNING id INTO v_new_date_id;

    -- Determine target gender for notifications
    v_target_gender := CASE WHEN v_proposer_gender = 'Male' THEN 'Female'::public.gender_enum ELSE 'Male'::public.gender_enum END;

    -- Find nearby users and create notifications
    FOR nearby_user IN
        SELECT p.id
        FROM public.profiles p
        WHERE
            p.id != v_proposer_id
            AND p.gender = v_target_gender
            AND p.latitude IS NOT NULL AND p.longitude IS NOT NULL
            -- Check for blocks
            AND NOT EXISTS (
                SELECT 1 FROM public.reports_blocks rb
                WHERE (rb.reporting_user_id = v_proposer_id AND rb.reported_user_id = p.id)
                   OR (rb.reporting_user_id = p.id AND rb.reported_user_id = v_proposer_id)
            )
            -- Use PostGIS to find users within 10km
            AND extensions.ST_DWithin(
                extensions.ST_MakePoint(p.longitude, p.latitude)::geography,
                extensions.ST_MakePoint(v_proposer_lon, v_proposer_lat)::geography,
                10000 -- 10km radius in meters
            )
    LOOP
        -- Insert a notification for each nearby user
        INSERT INTO public.notifications (user_id, type, message, source_entity_id)
        VALUES (nearby_user.id, 'new_blind_date_request', v_proposer_name || ' has proposed a blind date near you!', v_new_date_id);
    END LOOP;

    RETURN v_new_date_id;
END;
$$;


-- Updated function to get nearby proposals AND include proposer's basic profile data
CREATE OR REPLACE FUNCTION public.get_nearby_proposals(p_user_id uuid)
RETURNS TABLE (
    id uuid,
    cafe text,
    meal public.meal_type,
    date_time timestamptz,
    proposer_id uuid,
    proposer_name text,
    proposer_profile_pics text[],
    proposer_college text,
    proposer_course text,
    proposer_tags text[],
    proposer_bio text,
    proposer_prompts jsonb
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_user_lat numeric;
    v_user_lon numeric;
    v_user_gender public.gender_enum;
    v_target_gender public.gender_enum;
BEGIN
    SELECT latitude, longitude, gender INTO v_user_lat, v_user_lon, v_user_gender FROM public.profiles WHERE id = p_user_id;
    IF v_user_lat IS NULL OR v_user_lon IS NULL THEN RETURN; END IF;
    v_target_gender := CASE WHEN v_user_gender = 'Male' THEN 'Female'::public.gender_enum ELSE 'Male'::public.gender_enum END;

    RETURN QUERY
    SELECT
        bd.id,
        bd.cafe,
        bd.meal::public.meal_type,
        bd.date_time,
        proposer.id as proposer_id,
        proposer.name as proposer_name,
        proposer."profilePics" as proposer_profile_pics,
        proposer.college as proposer_college,
        proposer.course as proposer_course,
        proposer.tags as proposer_tags,
        proposer.bio as proposer_bio,
        proposer.prompts as proposer_prompts
    FROM public.blind_dates bd
    JOIN public.profiles proposer ON bd.requesting_user_id = proposer.id
    WHERE bd.requested_user_id IS NULL
      AND bd.requesting_user_id != p_user_id
      AND bd.date_time > now()
      AND proposer.gender = v_target_gender
      AND proposer.latitude IS NOT NULL AND proposer.longitude IS NOT NULL
      AND NOT EXISTS (SELECT 1 FROM public.reports_blocks rb WHERE (rb.reporting_user_id = p_user_id AND rb.reported_user_id = proposer.id) OR (rb.reporting_user_id = proposer.id AND rb.reported_user_id = p_user_id))
      AND extensions.ST_DWithin(
          extensions.ST_MakePoint(proposer.longitude, proposer.latitude)::geography,
          extensions.ST_MakePoint(v_user_lon, v_user_lat)::geography,
          10000 -- 10km radius in meters
      )
    ORDER BY bd.date_time ASC;
END;
$$;

-- New function to get a user's OWN PENDING proposals
CREATE OR REPLACE FUNCTION public.get_my_proposals(p_user_id uuid)
RETURNS SETOF public.blind_dates
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT bd.*
    FROM public.blind_dates bd
    WHERE bd.requesting_user_id = p_user_id
      AND bd.requested_user_id IS NULL -- This is what makes it a proposal
      AND bd.date_time > now()
    ORDER BY bd.date_time ASC;
END;
$$;

-- New function to atomically accept a date proposal
CREATE OR REPLACE FUNCTION public.accept_proposal(p_date_id uuid, p_acceptor_id uuid)
RETURNS boolean
LANGUAGE plpgsql
AS $$
DECLARE
    v_updated_rows int;
BEGIN
    UPDATE public.blind_dates
    SET
        requested_user_id = p_acceptor_id,
        status = 'accepted'
    WHERE
        id = p_date_id
        AND requested_user_id IS NULL; -- Atomic check to prevent race condition
    GET DIAGNOSTICS v_updated_rows = ROW_COUNT;
    RETURN v_updated_rows > 0;
END;
$$;

-- New secure function for a user to cancel their own proposal
CREATE OR REPLACE FUNCTION public.cancel_my_proposal(p_date_id uuid)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    DELETE FROM public.blind_dates
    WHERE id = p_date_id
      AND requesting_user_id = auth.uid()
      AND requested_user_id IS NULL; -- Can only cancel if it's still a proposal
END;
$$;

-- New function to get a user's dates with their vibecheck status
CREATE OR REPLACE FUNCTION public.get_my_dates(p_user_id uuid)
RETURNS TABLE (
    id uuid,
    cafe text,
    meal public.meal_type,
    date_time timestamptz,
    status public.blind_date_status,
    is_receiver boolean,
    other_user_id uuid,
    other_user_name text,
    other_user_profile_pics text[],
    other_user_college text,
    other_user_course text,
    other_user_tags text[],
    other_user_bio text,
    other_user_prompts jsonb,
    vibe_check_rating public.vibe_rating,
    vibe_check_tags text[]
)
LANGUAGE sql
AS $$
SELECT
    bd.id,
    bd.cafe,
    bd.meal::public.meal_type,
    bd.date_time,
    bd.status,
    (bd.requested_user_id = p_user_id) as is_receiver,
    ou.id as other_user_id,
    ou.name as other_user_name,
    ou."profilePics" as other_user_profile_pics,
    ou.college as other_user_college,
    ou.course as other_user_course,
    ou.tags as other_user_tags,
    ou.bio as other_user_bio,
    ou.prompts as other_user_prompts,
    vc.rating as vibe_check_rating,
    vc.tags as vibe_check_tags
FROM
    public.blind_dates bd
JOIN
    public.profiles ou ON ou.id = CASE
        WHEN bd.requesting_user_id = p_user_id THEN bd.requested_user_id
        ELSE bd.requesting_user_id
    END
LEFT JOIN
    public.vibe_checks vc ON vc.blind_date_id = bd.id AND vc.user_id = p_user_id
WHERE
    (bd.requesting_user_id = p_user_id OR bd.requested_user_id = p_user_id)
    AND bd.requested_user_id IS NOT NULL
ORDER BY
    bd.date_time DESC;
$$;


CREATE OR REPLACE FUNCTION public.handle_swipe(p_swiper_id uuid, p_swiped_id uuid, p_direction public.swipe_direction)
RETURNS TABLE(match_created boolean, conversation_id uuid)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE v_match_exists boolean; v_conversation_id uuid;
BEGIN
    INSERT INTO public.swipes(swiper_id, swiped_id, direction) VALUES (p_swiper_id, p_swiped_id, p_direction)
    ON CONFLICT (swiper_id, swiped_id) DO UPDATE SET direction = p_direction;
    IF p_direction = 'right' THEN
        SELECT EXISTS (SELECT 1 FROM public.swipes WHERE swiper_id = p_swiped_id AND swiped_id = p_swiper_id AND direction = 'right') INTO v_match_exists;
        IF v_match_exists THEN
            INSERT INTO public.conversations(user1_id, user2_id) VALUES (LEAST(p_swiper_id, p_swiped_id), GREATEST(p_swiper_id, p_swiped_id))
            ON CONFLICT(user1_id, user2_id) DO NOTHING;
            SELECT c.id INTO v_conversation_id FROM public.conversations c WHERE (c.user1_id = p_swiper_id AND c.user2_id = p_swiped_id) OR (c.user1_id = p_swiped_id AND c.user2_id = p_swiper_id);
            RETURN QUERY SELECT true, v_conversation_id;
        ELSE RETURN QUERY SELECT false, null::uuid; END IF;
    ELSE RETURN QUERY SELECT false, null::uuid; END IF;
END; $$;
CREATE OR REPLACE FUNCTION public.get_conversations(p_user_id uuid)
RETURNS TABLE(id uuid, other_user_id uuid, other_user_name text, other_user_profile_pic text, last_message_text text, last_message_timestamp timestamptz, last_message_sender_id uuid)
LANGUAGE sql AS $$
WITH last_messages AS (SELECT conversation_id, text, created_at, sender_id, ROW_NUMBER() OVER(PARTITION BY conversation_id ORDER BY created_at DESC) as rn FROM public.messages)
SELECT c.id, p.id AS other_user_id, p.name AS other_user_name, p."profilePics"[1] AS other_user_profile_pic, lm.text AS last_message_text, lm.created_at AS last_message_timestamp, lm.sender_id AS last_message_sender_id
FROM public.conversations c JOIN public.profiles p ON (p.id = c.user1_id OR p.id = c.user2_id) AND p.id <> p_user_id
LEFT JOIN last_messages lm ON lm.conversation_id = c.id AND lm.rn = 1 WHERE c.user1_id = p_user_id OR c.user2_id = p_user_id ORDER BY lm.created_at DESC NULLS LAST; $$;
CREATE OR REPLACE FUNCTION public.get_events_with_rsvp(p_user_id uuid)
RETURNS TABLE (id uuid, created_at timestamptz, name text, date text, college text, "imageUrl" text, rsvp_status public.rsvp_status)
LANGUAGE sql AS $$
SELECT e.id, e.created_at, e.name, e.date, e.college, e."imageUrl", er.status as rsvp_status
FROM public.events e LEFT JOIN public.event_rsvps er ON e.id = er.event_id AND er.user_id = p_user_id ORDER BY e.date; $$;
CREATE OR REPLACE FUNCTION public.get_likers(p_user_id uuid)
RETURNS SETOF public.profiles
LANGUAGE sql AS $$
    SELECT p.*
    FROM public.profiles p
    JOIN public.swipes s ON p.id = s.swiper_id
    WHERE s.swiped_id = p_user_id AND s.direction = 'right'
    AND NOT EXISTS (SELECT 1 FROM public.swipes s2 WHERE s2.swiper_id = p_user_id AND s2.swiped_id = p.id);
$$;
CREATE OR REPLACE FUNCTION public.get_swipe_candidates(p_user_id uuid, p_user_gender public.gender_enum)
RETURNS SETOF public.profiles
LANGUAGE sql AS $$
    SELECT p.*
    FROM public.profiles p
    WHERE p.id <> p_user_id
        AND p.gender = (CASE WHEN p_user_gender = 'Male' THEN 'Female'::public.gender_enum ELSE 'Male'::public.gender_enum END)
        AND NOT EXISTS (SELECT 1 FROM public.swipes s WHERE s.swiper_id = p_user_id AND s.swiped_id = p.id)
        AND NOT EXISTS (SELECT 1 FROM public.reports_blocks rb WHERE rb.reporting_user_id = p_user_id AND rb.reported_user_id = p.id AND rb.type = 'block')
        AND NOT EXISTS (SELECT 1 FROM public.reports_blocks rb WHERE rb.reporting_user_id = p.id AND rb.reported_user_id = p_user_id AND rb.type = 'block')
    ORDER BY random() LIMIT 20;
$$;
CREATE OR REPLACE FUNCTION public.book_trip_and_decrement_slot(p_trip_id uuid, p_user_id uuid)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE current_slots integer; already_booked boolean;
BEGIN
  SELECT slots INTO current_slots FROM public.trips WHERE id = p_trip_id FOR UPDATE;
  SELECT EXISTS (SELECT 1 FROM public.trip_bookings WHERE trip_id = p_trip_id AND user_id = p_user_id) INTO already_booked;
  IF already_booked THEN RETURN true; END IF;
  IF current_slots > 0 THEN
    INSERT INTO public.trip_bookings(trip_id, user_id) VALUES (p_trip_id, p_user_id);
    UPDATE public.trips SET slots = slots - 1 WHERE id = p_trip_id;
    RETURN true;
  ELSE RETURN false; END IF;
END; $$;

-- New function for securely deleting a user's account
CREATE OR REPLACE FUNCTION public.delete_user_account()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    -- This function will trigger the on_auth_user_deleted trigger
    -- which handles deleting the profile and storage files.
    DELETE FROM auth.users WHERE id = auth.uid();
END;
$$;


-- 4. TRIGGERS & TRIGGER FUNCTIONS
CREATE OR REPLACE FUNCTION public.handle_vibe_check_match()
RETURNS TRIGGER AS $$
DECLARE v_date_id uuid; v_feedback_count int; v_good_vibes_count int; v_user1_id uuid; v_user2_id uuid; v_user1_name text; v_user2_name text;
BEGIN
  v_date_id := NEW.blind_date_id;
  SELECT count(*) INTO v_feedback_count FROM public.vibe_checks WHERE blind_date_id = v_date_id;
  IF v_feedback_count = 2 THEN
    UPDATE public.blind_dates SET status = 'feedback_submitted' WHERE id = v_date_id;
    SELECT count(*) INTO v_good_vibes_count FROM public.vibe_checks WHERE blind_date_id = v_date_id AND rating = 'good';
    IF v_good_vibes_count = 2 THEN
      SELECT bd.requesting_user_id, bd.requested_user_id, p1.name, p2.name
      INTO v_user1_id, v_user2_id, v_user1_name, v_user2_name
      FROM public.blind_dates bd
      JOIN public.profiles p1 ON bd.requesting_user_id = p1.id
      JOIN public.profiles p2 ON bd.requested_user_id = p2.id
      WHERE bd.id = v_date_id;
      INSERT INTO public.notifications(user_id, type, message, source_entity_id) VALUES (v_user1_id, 'vibe_check_match', 'Your VibeCheck with ' || v_user2_name || ' was a success! You can now chat.', v_date_id);
      INSERT INTO public.notifications(user_id, type, message, source_entity_id) VALUES (v_user2_id, 'vibe_check_match', 'Your VibeCheck with ' || v_user1_name || ' was a success! You can now chat.', v_date_id);
      PERFORM public.handle_swipe(v_user1_id, v_user2_id, 'right');
      PERFORM public.handle_swipe(v_user2_id, v_user1_id, 'right');
    END IF;
  END IF; RETURN NEW;
END; $$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.create_new_match_notification()
RETURNS TRIGGER AS $$
DECLARE user1_name text; user2_name text;
BEGIN
    SELECT name INTO user1_name FROM public.profiles WHERE id = NEW.user1_id;
    SELECT name INTO user2_name FROM public.profiles WHERE id = NEW.user2_id;
    INSERT INTO public.notifications(user_id, type, message, source_entity_id) VALUES (NEW.user1_id, 'new_match', 'You matched with ' || user2_name || '!', NEW.id);
    INSERT INTO public.notifications(user_id, type, message, source_entity_id) VALUES (NEW.user2_id, 'new_match', 'You matched with ' || user1_name || '!', NEW.id);
    RETURN NEW;
END; $$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.create_new_message_notification()
RETURNS TRIGGER AS $$
DECLARE recipient_id uuid; sender_name text;
BEGIN
    SELECT CASE WHEN user1_id = NEW.sender_id THEN user2_id ELSE user1_id END INTO recipient_id FROM public.conversations WHERE id = NEW.conversation_id;
    SELECT name INTO sender_name FROM public.profiles WHERE id = NEW.sender_id;
    INSERT INTO public.notifications(user_id, type, message, source_entity_id) VALUES(recipient_id, 'new_message', 'New message from ' || sender_name, NEW.conversation_id);
    RETURN NEW;
END; $$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.create_blind_date_notification()
RETURNS TRIGGER AS $$
DECLARE requesting_user_name text; requested_user_name text;
BEGIN
    -- This trigger now ONLY handles ACCEPTED dates. Proposal notifications are handled by the propose_blind_date function.
    IF (TG_OP = 'UPDATE' AND OLD.status = 'pending' AND NEW.status = 'accepted' AND NEW.requested_user_id IS NOT NULL) THEN
        SELECT name INTO requested_user_name FROM public.profiles WHERE id = NEW.requested_user_id;
        INSERT INTO public.notifications(user_id, type, message, source_entity_id) VALUES(NEW.requesting_user_id, 'blind_date_accepted', 'Your blind date with ' || requested_user_name || ' was accepted!', NEW.id);
    END IF; RETURN NEW;
END; $$ LANGUAGE plpgsql;

-- This function cleans up a user's data after their auth.users entry is deleted.
CREATE OR REPLACE FUNCTION public.handle_delete_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public AS $$
BEGIN
  -- Delete the user's profile from the public profiles table
  DELETE FROM public.profiles WHERE id = old.id;
  
  -- Delete all of the user's files from storage
  -- Note: This requires the service_role key, which this function has due to "SECURITY DEFINER"
  DELETE FROM storage.objects WHERE bucket_id = 'profile-pics' AND owner = old.id;
  
  RETURN old;
END; $$;

DROP TRIGGER IF EXISTS on_vibe_check_insert ON public.vibe_checks;
CREATE TRIGGER on_vibe_check_insert AFTER INSERT ON public.vibe_checks FOR EACH ROW EXECUTE FUNCTION public.handle_vibe_check_match();
DROP TRIGGER IF EXISTS on_new_match ON public.conversations;
CREATE TRIGGER on_new_match AFTER INSERT ON public.conversations FOR EACH ROW EXECUTE FUNCTION public.create_new_match_notification();
DROP TRIGGER IF EXISTS on_new_message ON public.messages;
CREATE TRIGGER on_new_message AFTER INSERT ON public.messages FOR EACH ROW EXECUTE FUNCTION public.create_new_message_notification();
DROP TRIGGER IF EXISTS on_blind_date_change ON public.blind_dates;
CREATE TRIGGER on_blind_date_change AFTER INSERT OR UPDATE ON public.blind_dates FOR EACH ROW EXECUTE FUNCTION public.create_blind_date_notification();
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;
CREATE TRIGGER on_auth_user_deleted AFTER DELETE ON auth.users FOR EACH ROW EXECUTE PROCEDURE public.handle_delete_user();

-- 5. ROW LEVEL SECURITY (RLS)
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.swipes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.conversations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.events ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.event_rsvps ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.trips ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.trip_bookings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.blind_dates ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.comments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.reports_blocks ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.vibe_checks ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profile_boosts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.rizz_scores ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.payments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ads ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Allow all access for own profile" ON public.profiles;
DROP POLICY IF EXISTS "Allow authenticated users to read profiles" ON public.profiles;
DROP POLICY IF EXISTS "Allow management of own swipes" ON public.swipes;
DROP POLICY IF EXISTS "Allow reading of received swipes" ON public.swipes;
DROP POLICY IF EXISTS "Enable read access for involved users" ON public.conversations;
DROP POLICY IF EXISTS "Enable read access for involved users" ON public.messages;
DROP POLICY IF EXISTS "Enable insert for involved users" ON public.messages;
DROP POLICY IF EXISTS "Allow authenticated users to read all events and trips" ON public.events;
DROP POLICY IF EXISTS "Allow authenticated users to read all events and trips" ON public.trips;
DROP POLICY IF EXISTS "Enable all actions for own RSVPs" ON public.event_rsvps;
DROP POLICY IF EXISTS "Enable all actions for own trip bookings" ON public.trip_bookings;
DROP POLICY IF EXISTS "Enable create/delete for own proposals/dates" ON public.blind_dates;
DROP POLICY IF EXISTS "Enable authenticated read access" ON public.blind_dates;
DROP POLICY IF EXISTS "Allow authenticated users to read comments" ON public.comments;
DROP POLICY IF EXISTS "Enable insert for own comments" ON public.comments;
DROP POLICY IF EXISTS "Enable delete for own comments" ON public.comments;
DROP POLICY IF EXISTS "Enable all actions for own reports and blocks" ON public.reports_blocks;
DROP POLICY IF EXISTS "Enable all actions for own vibe checks" ON public.vibe_checks;
DROP POLICY IF EXISTS "Enable all actions for own profile boosts" ON public.profile_boosts;
DROP POLICY IF EXISTS "Enable all actions for own rizz scores" ON public.rizz_scores;
DROP POLICY IF EXISTS "Enable all actions for own notifications" ON public.notifications;
DROP POLICY IF EXISTS "Enable all actions for own payments" ON public.payments;
DROP POLICY IF EXISTS "Allow authenticated users to read ads" ON public.ads;

CREATE POLICY "Allow authenticated users to read profiles" ON public.profiles FOR SELECT TO authenticated USING (true);
CREATE POLICY "Allow all access for own profile" ON public.profiles FOR ALL USING (auth.uid() = id) WITH CHECK (auth.uid() = id);
CREATE POLICY "Allow management of own swipes" ON public.swipes FOR ALL USING (auth.uid() = swiper_id) WITH CHECK (auth.uid() = swiper_id);
CREATE POLICY "Allow reading of received swipes" ON public.swipes FOR SELECT USING (auth.uid() = swiped_id);
CREATE POLICY "Enable read access for involved users" ON public.conversations FOR SELECT USING (auth.uid() = user1_id OR auth.uid() = user2_id);
CREATE POLICY "Enable read access for involved users" ON public.messages FOR SELECT USING (conversation_id IN (SELECT c.id FROM public.conversations c WHERE auth.uid() = c.user1_id OR auth.uid() = c.user2_id));
CREATE POLICY "Enable insert for involved users" ON public.messages FOR INSERT WITH CHECK (auth.uid() = sender_id AND conversation_id IN (SELECT c.id FROM public.conversations c WHERE auth.uid() = c.user1_id OR auth.uid() = c.user2_id));
CREATE POLICY "Allow authenticated users to read comments" ON public.comments FOR SELECT TO authenticated USING (true);
CREATE POLICY "Enable insert for own comments" ON public.comments FOR INSERT WITH CHECK (auth.uid() = author_id);
CREATE POLICY "Enable delete for own comments" ON public.comments FOR DELETE USING (auth.uid() = author_id);
CREATE POLICY "Allow authenticated users to read all events and trips" ON public.events FOR SELECT TO authenticated USING (true);
CREATE POLICY "Allow authenticated users to read all events and trips" ON public.trips FOR SELECT TO authenticated USING (true);
CREATE POLICY "Enable all actions for own RSVPs" ON public.event_rsvps FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Enable all actions for own trip bookings" ON public.trip_bookings FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Enable create/delete for own proposals/dates" ON public.blind_dates FOR ALL USING (auth.uid() = requesting_user_id OR auth.uid() = requested_user_id) WITH CHECK (auth.uid() = requesting_user_id);
CREATE POLICY "Enable authenticated read access" ON public.blind_dates FOR SELECT USING (true);
CREATE POLICY "Enable all actions for own reports and blocks" ON public.reports_blocks FOR ALL USING (auth.uid() = reporting_user_id) WITH CHECK (auth.uid() = reporting_user_id);
CREATE POLICY "Enable all actions for own vibe checks" ON public.vibe_checks FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Enable all actions for own profile boosts" ON public.profile_boosts FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Enable all actions for own rizz scores" ON public.rizz_scores FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Enable all actions for own notifications" ON public.notifications FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Enable all actions for own payments" ON public.payments FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Allow authenticated users to read ads" ON public.ads FOR SELECT TO authenticated USING (true);